<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CLAIM TOKEN $GODMODE - FREE MINT</title>

<!-- Farcaster Frame Meta Tags -->
<meta property="fc:frame" content="vNext">
<meta property="fc:frame:image" content="https://claim-godmode-token.vercel.app/og.png">
<meta property="fc:frame:image:aspect_ratio" content="1.91:1">
<meta property="fc:frame:button:1" content="üöÄ MINT NOW">
<meta property="fc:frame:button:1:action" content="link">
<meta property="fc:frame:button:1:target" content="https://claim-godmode-token.vercel.app/app.html">
<meta property="fc:frame:post_url" content="https://claim-godmode-token.vercel.app/.netlify/functions/frame">

<!-- Open Graph -->
<meta property="og:title" content="CLAIM TOKEN $GODMODE - FREE MINT">
<meta property="og:description" content="Mint $GODMODE tokens on Base Mainnet. 1B total supply, 50x max per user!">
<meta property="og:image" content="https://claim-godmode-token.vercel.app/og.png">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: #fff;
        }

        .container {
            max-width: 500px;
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .logo {
            text-align: center;
            margin-bottom: 30px;
        }

        .logo h1 {
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            margin-bottom: 10px;
        }

        .logo p {
            font-size: 16px;
            opacity: 0.9;
            font-weight: 500;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 16px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-card .label {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-card .value {
            font-size: 24px;
            font-weight: 700;
            color: #ffd700;
        }

        .progress-section {
            margin-bottom: 30px;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            transition: width 0.5s ease;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .mint-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 16px;
            margin-bottom: 20px;
        }

        .mint-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .mint-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mint-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .mint-amount {
            font-size: 36px;
            font-weight: 700;
            min-width: 60px;
            text-align: center;
        }

        .mint-info {
            text-align: center;
            margin-bottom: 20px;
        }

        .mint-info p {
            font-size: 14px;
            opacity: 0.9;
            margin: 5px 0;
        }

        .mint-info .highlight {
            color: #ffd700;
            font-weight: 700;
        }

        .connect-btn, .mint-action-btn {
            width: 100%;
            padding: 18px;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .connect-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: #fff;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .mint-action-btn {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #000;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }

        .mint-action-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .mint-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .wallet-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 14px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
        }

        .network-info {
            text-align: center;
            margin-bottom: 15px;
            font-size: 12px;
            padding: 10px;
            background: rgba(0, 123, 255, 0.2);
            border-radius: 8px;
            border: 1px solid rgba(0, 123, 255, 0.3);
        }

        .status-message {
            text-align: center;
            padding: 15px;
            border-radius: 12px;
            margin-top: 20px;
            font-size: 14px;
            display: none;
        }

        .status-message.success {
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.4);
            display: block;
        }

        .status-message.error {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.4);
            display: block;
        }

        .status-message.info {
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.4);
            display: block;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .share-btn {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: #fff;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.3s;
        }

        .share-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        @media (max-width: 480px) {
            .container {
                padding: 25px;
            }
            
            .logo h1 {
                font-size: 36px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <h1>$GODMODE</h1>
            <p>FREE MINT ON BASE MAINNET</p>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="label">Total Supply</div>
                <div class="value">1B</div>
            </div>
            <div class="stat-card">
                <div class="label">Max Per User</div>
                <div class="value">50x</div>
            </div>
            <div class="stat-card">
                <div class="label">Per Mint</div>
                <div class="value">45K</div>
            </div>
            <div class="stat-card">
                <div class="label">Your Mints</div>
                <div class="value" id="userMints">0</div>
            </div>
        </div>

        <div class="progress-section">
            <div class="progress-header">
                <span>Minting Progress</span>
                <span id="progressText">0 / 20,000</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>

        <div class="mint-section">
            <div class="mint-controls">
                <button class="mint-btn" id="decreaseBtn">‚àí</button>
                <div class="mint-amount" id="mintAmount">1</div>
                <button class="mint-btn" id="increaseBtn">+</button>
            </div>

            <div class="mint-info">
                <p>Tokens: <span class="highlight" id="tokensAmount">45,000</span></p>
                <p>Cost: <span class="highlight" id="costAmount">0.00012 ETH</span></p>
                <p style="font-size: 12px; opacity: 0.7; margin-top: 10px;">*Small network fee applies</p>
            </div>

            <div id="walletSection">
                <button class="connect-btn" id="connectBtn">
                    üîó Connect Wallet
                </button>
            </div>

            <div id="mintSection" style="display: none;">
                <div class="network-info" id="networkInfo"></div>
                <div class="wallet-info" id="walletInfo"></div>
                <button class="mint-action-btn" id="mintBtn">
                    üöÄ MINT NOW
                </button>
                <button class="share-btn" id="shareBtn" style="display: none;">
                    üì¢ Share on Farcaster
                </button>
            </div>
        </div>

        <div class="status-message" id="statusMessage"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script type="module">
        import sdk from 'https://esm.sh/@farcaster/frame-sdk@0.1.1';
        
        // Initialize SDK immediately
        (async () => {
            try {
                window.frameSDK = sdk;
                
                // Get context first to check if we're in a frame
                const context = await sdk.context;
                console.log('Frame context:', context);
                
                // Call ready() to signal we're ready
                await sdk.actions.ready();
                console.log('‚úÖ Farcaster SDK ready');
                
                window.isFarcasterFrame = true;
                window.dispatchEvent(new Event('farcaster-ready'));
            } catch (err) {
                console.log('Running in standalone mode:', err);
                window.isFarcasterFrame = false;
                window.dispatchEvent(new Event('farcaster-ready'));
            }
        })();
    </script>
    
    <script>
        const CONTRACT_ADDRESS = '0xfe0b0148A535ab66F83e19756A20A0b9fCAF1305';
        const BASE_CHAIN_ID = 8453;
        const BASE_CHAIN_ID_HEX = '0x2105';
        const TOKENS_PER_MINT = 45000;
        const MINT_PRICE = '0.00012';
        const MAX_MINTS_PER_USER = 50;

        const CONTRACT_ABI = [
            "function mint(uint256 mintCount) external payable",
            "function totalMintCount() external view returns (uint256)",
            "function userMintCount(address) external view returns (uint256)",
            "function remainingMints() external view returns (uint256)",
            "function remainingMintsForUser(address) external view returns (uint256)",
            "function TOTAL_MINTS_AVAILABLE() external view returns (uint256)"
        ];

        let provider = null;
        let signer = null;
        let contract = null;
        let userAddress = null;
        let currentMintAmount = 1;
        let isConnected = false;

        async function initApp() {
            console.log('Initializing app...');
            
            // Wait for ethers to load
            while (!window.ethers) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            console.log('‚úÖ Ethers loaded');

            // Load contract data immediately
            await loadContractData();

            // Auto-connect if in Farcaster
            if (window.isFarcasterFrame) {
                console.log('Detected Farcaster Frame mode');
                setTimeout(async () => {
                    await autoConnectFarcasterWallet();
                }, 500);
            } else {
                console.log('Standalone mode - manual connect required');
            }
        }

        // Start initialization when ready
        window.addEventListener('farcaster-ready', initApp);

        async function autoConnectFarcasterWallet() {
            try {
                const sdk = window.frameSDK;
                if (!sdk || !sdk.wallet) {
                    console.log('Farcaster wallet not available');
                    return;
                }

                console.log('Attempting Farcaster wallet connection...');
                showStatus('üîó Connecting to Farcaster wallet...', 'info');

                // Check if ethProvider is available
                if (!sdk.wallet.ethProvider) {
                    console.log('No ethProvider found');
                    return;
                }

                // Get wallet address
                let accounts;
                try {
                    // Try eth_accounts first (doesn't require permission)
                    accounts = await sdk.wallet.ethProvider.request({
                        method: 'eth_accounts'
                    });
                    
                    // If no accounts, request permission
                    if (!accounts || accounts.length === 0) {
                        accounts = await sdk.wallet.ethProvider.request({
                            method: 'eth_requestAccounts'
                        });
                    }
                } catch (e) {
                    console.error('Failed to get accounts:', e);
                    return;
                }

                if (!accounts || accounts.length === 0) {
                    console.log('No accounts found');
                    return;
                }

                userAddress = accounts[0];
                console.log('Got address:', userAddress);
                
                // Create Farcaster-compatible provider
                const FarcasterProvider = class extends window.ethers.providers.BaseProvider {
                    constructor(ethProvider) {
                        super(BASE_CHAIN_ID);
                        this.ethProvider = ethProvider;
                    }
                    
                    async perform(method, params) {
                        if (method === 'getTransactionReceipt') {
                            const receipt = await this.ethProvider.request({
                                method: 'eth_getTransactionReceipt',
                                params: [params.transactionHash]
                            });
                            return receipt;
                        }
                        
                        if (method === 'getBlock') {
                            const block = await this.ethProvider.request({
                                method: 'eth_getBlockByNumber',
                                params: [params.blockTag || 'latest', false]
                            });
                            return block;
                        }
                        
                        if (method === 'call') {
                            return await this.ethProvider.request({
                                method: 'eth_call',
                                params: [params.transaction, 'latest']
                            });
                        }
                        
                        if (method === 'estimateGas') {
                            return await this.ethProvider.request({
                                method: 'eth_estimateGas',
                                params: [params.transaction]
                            });
                        }
                        
                        if (method === 'sendTransaction') {
                            return await this.ethProvider.request({
                                method: 'eth_sendTransaction',
                                params: [params.signedTransaction]
                            });
                        }
                        
                        throw new Error(`Unsupported method: ${method}`);
                    }
                    
                    getSigner() {
                        return new FarcasterSigner(this.ethProvider, this);
                    }
                };
                
                const FarcasterSigner = class extends window.ethers.Signer {
                    constructor(ethProvider, provider) {
                        super();
                        this.ethProvider = ethProvider;
                        this.provider = provider;
                    }
                    
                    async getAddress() {
                        const accounts = await this.ethProvider.request({
                            method: 'eth_accounts'
                        });
                        return accounts[0];
                    }
                    
                    async signMessage(message) {
                        const address = await this.getAddress();
                        return await this.ethProvider.request({
                            method: 'personal_sign',
                            params: [message, address]
                        });
                    }
                    
                    async sendTransaction(transaction) {
                        const tx = await window.ethers.utils.resolveProperties(transaction);
                        const hash = await this.ethProvider.request({
                            method: 'eth_sendTransaction',
                            params: [tx]
                        });
                        return this.provider.getTransaction(hash);
                    }
                    
                    connect(provider) {
                        return new FarcasterSigner(this.ethProvider, provider);
                    }
                };
                
                provider = new FarcasterProvider(sdk.wallet.ethProvider);
                signer = provider.getSigner();
                contract = new window.ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                isConnected = true;

                updateUI();
                await updateUserMints();
                showStatus('‚úÖ Farcaster wallet connected!', 'success');

                console.log('‚úÖ Auto-connected successfully');
            } catch (error) {
                console.error('Auto-connect error:', error);
                // Don't show error to user, just log it
            }
        }

        async function ensureCorrectNetwork(provider, ethProvider) {
            try {
                const network = await provider.getNetwork();
                console.log('Current network:', network.chainId);
                
                if (network.chainId !== BASE_CHAIN_ID) {
                    console.log('Switching to Base Mainnet...');
                    showStatus('üîÑ Switching to Base Mainnet...', 'info');
                    
                    try {
                        await ethProvider.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: BASE_CHAIN_ID_HEX }],
                        });
                        console.log('‚úÖ Switched to Base Mainnet');
                    } catch (switchError) {
                        // If network doesn't exist, add it
                        if (switchError.code === 4902) {
                            await ethProvider.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: BASE_CHAIN_ID_HEX,
                                    chainName: 'Base Mainnet',
                                    nativeCurrency: {
                                        name: 'Ethereum',
                                        symbol: 'ETH',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://mainnet.base.org'],
                                    blockExplorerUrls: ['https://basescan.org']
                                }]
                            });
                            console.log('‚úÖ Base Mainnet added');
                        } else {
                            throw switchError;
                        }
                    }
                    
                    // Refresh provider after network change
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    provider = new window.ethers.providers.Web3Provider(ethProvider, 'any');
                }
                
                document.getElementById('networkInfo').textContent = '‚úÖ Connected to Base Mainnet';
            } catch (error) {
                console.error('Network switch error:', error);
                document.getElementById('networkInfo').textContent = '‚ö†Ô∏è Please switch to Base Mainnet';
                throw error;
            }
        }

        async function loadContractData() {
            try {
                const baseProvider = new window.ethers.providers.JsonRpcProvider('https://mainnet.base.org');
                const readContract = new window.ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, baseProvider);
                
                const totalMints = await readContract.totalMintCount();
                const totalAvailable = await readContract.TOTAL_MINTS_AVAILABLE();
                
                updateProgress(totalMints.toNumber(), totalAvailable.toNumber());
            } catch (error) {
                console.error('Error loading contract data:', error);
            }
        }

        document.getElementById('connectBtn').addEventListener('click', async () => {
            try {
                showStatus('üîó Connecting wallet...', 'info');
                
                const sdk = window.frameSDK;
                
                if (sdk && sdk.wallet && sdk.wallet.ethProvider) {
                    // Farcaster wallet
                    const accounts = await sdk.wallet.ethProvider.request({
                        method: 'eth_requestAccounts'
                    });

                    if (!accounts || accounts.length === 0) {
                        throw new Error('No Farcaster wallet found');
                    }

                    userAddress = accounts[0];
                    provider = new window.ethers.providers.Web3Provider(sdk.wallet.ethProvider, 'any');
                    
                    await ensureCorrectNetwork(provider, sdk.wallet.ethProvider);
                    
                    signer = provider.getSigner();
                } else if (window.ethereum) {
                    // Browser wallet (MetaMask, etc)
                    const accounts = await window.ethereum.request({
                        method: 'eth_requestAccounts'
                    });
                    
                    userAddress = accounts[0];
                    provider = new window.ethers.providers.Web3Provider(window.ethereum);
                    
                    await ensureCorrectNetwork(provider, window.ethereum);
                    
                    signer = provider.getSigner();
                } else {
                    throw new Error('Please install MetaMask or open in Farcaster app');
                }

                contract = new window.ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                isConnected = true;

                updateUI();
                await updateUserMints();
                showStatus('‚úÖ Wallet connected!', 'success');
            } catch (error) {
                console.error('Connection error:', error);
                showStatus('‚ùå ' + error.message, 'error');
            }
        });

        function updateUI() {
            document.getElementById('walletSection').style.display = 'none';
            document.getElementById('mintSection').style.display = 'block';
            document.getElementById('walletInfo').textContent = 
                `Connected: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
        }

        document.getElementById('decreaseBtn').addEventListener('click', () => {
            if (currentMintAmount > 1) {
                currentMintAmount--;
                updateMintDisplay();
            }
        });

        document.getElementById('increaseBtn').addEventListener('click', () => {
            if (currentMintAmount < MAX_MINTS_PER_USER) {
                currentMintAmount++;
                updateMintDisplay();
            }
        });

        function updateMintDisplay() {
            document.getElementById('mintAmount').textContent = currentMintAmount;
            document.getElementById('tokensAmount').textContent = 
                (TOKENS_PER_MINT * currentMintAmount).toLocaleString();
            document.getElementById('costAmount').textContent = 
                (parseFloat(MINT_PRICE) * currentMintAmount).toFixed(5) + ' ETH';
        }

        document.getElementById('mintBtn').addEventListener('click', async () => {
            if (!isConnected || !contract) {
                showStatus('‚ùå Please connect wallet first', 'error');
                return;
            }

            try {
                const mintBtn = document.getElementById('mintBtn');
                mintBtn.disabled = true;
                mintBtn.innerHTML = '<span class="loading"></span> Minting...';

                // Check user mint limit first (using read-only provider)
                const baseProvider = new window.ethers.providers.JsonRpcProvider('https://mainnet.base.org');
                const readContract = new window.ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, baseProvider);
                
                const userMints = await readContract.userMintCount(userAddress);
                if (userMints.toNumber() + currentMintAmount > MAX_MINTS_PER_USER) {
                    throw new Error(`Exceeds maximum ${MAX_MINTS_PER_USER} mints per user`);
                }

                const value = window.ethers.utils.parseEther(
                    (parseFloat(MINT_PRICE) * currentMintAmount).toString()
                );

                console.log('Preparing mint:', {
                    amount: currentMintAmount,
                    value: value.toString(),
                    valueInEth: window.ethers.utils.formatEther(value),
                    address: userAddress
                });

                // Prepare transaction
                const txData = contract.interface.encodeFunctionData('mint', [currentMintAmount]);
                
                let txHash;
                
                if (window.isFarcasterFrame && window.frameSDK && window.frameSDK.wallet) {
                    // Farcaster transaction
                    console.log('Sending via Farcaster wallet...');
                    txHash = await window.frameSDK.wallet.ethProvider.request({
                        method: 'eth_sendTransaction',
                        params: [{
                            from: userAddress,
                            to: CONTRACT_ADDRESS,
                            data: txData,
                            value: '0x' + value.toHexString().slice(2),
                            gas: '0x493e0' // 300000 in hex
                        }]
                    });
                } else {
                    // Regular wallet transaction
                    const tx = await contract.mint(currentMintAmount, { 
                        value,
                        gasLimit: 300000
                    });
                    txHash = tx.hash;
                }
                
                showStatus('‚è≥ Transaction submitted! Waiting for confirmation...', 'info');
                console.log('Transaction hash:', txHash);

                // Wait for confirmation
                let confirmed = false;
                let attempts = 0;
                
                while (!confirmed && attempts < 60) { // 60 attempts = 2 minutes
                    try {
                        const receipt = await baseProvider.getTransactionReceipt(txHash);
                        if (receipt && receipt.confirmations >= 1) {
                            confirmed = true;
                            console.log('Transaction confirmed:', receipt);
                            
                            showStatus(
                                `üéâ Successfully minted ${(currentMintAmount * TOKENS_PER_MINT).toLocaleString()} $GODMODE tokens!`,
                                'success'
                            );
                            
                            await updateUserMints();
                            await loadContractData();
                            
                            document.getElementById('shareBtn').style.display = 'block';
                        }
                    } catch (e) {
                        // Receipt not ready yet
                    }
                    
                    if (!confirmed) {
                        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
                        attempts++;
                    }
                }
                
                if (!confirmed) {
                    showStatus('‚è≥ Transaction is pending. Check your wallet for status.', 'info');
                }
                
                mintBtn.disabled = false;
                mintBtn.textContent = 'üöÄ MINT NOW';
            } catch (error) {
                console.error('Mint error:', error);
                let errorMessage = 'Unknown error';
                
                if (error.message.includes('user rejected') || error.code === 4001) {
                    errorMessage = 'Transaction rejected by user';
                } else if (error.message.includes('insufficient funds')) {
                    errorMessage = 'Insufficient ETH balance';
                } else if (error.data && error.data.message) {
                    errorMessage = error.data.message;
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                showStatus('‚ùå Mint failed: ' + errorMessage, 'error');
                
                const mintBtn = document.getElementById('mintBtn');
                mintBtn.disabled = false;
                mintBtn.textContent = 'üöÄ MINT NOW';
            }
        });

        document.getElementById('shareBtn').addEventListener('click', () => {
            const text = encodeURIComponent(
                `Just minted ${(currentMintAmount * TOKENS_PER_MINT).toLocaleString()} $GODMODE tokens! üöÄ\n\nJoin the FREE MINT now on Base Mainnet!`
            );
            const url = encodeURIComponent('https://claim-godmode-token.vercel.app/');
            const castUrl = `https://warpcast.com/~/compose?text=${text}&embeds[]=${url}`;
            
            if (window.frameSDK && window.frameSDK.actions && window.frameSDK.actions.openUrl) {
                window.frameSDK.actions.openUrl(castUrl);
            } else {
                window.open(castUrl, '_blank');
            }
        });

        async function updateUserMints() {
            if (contract && userAddress) {
                try {
                    const mints = await contract.userMintCount(userAddress);
                    document.getElementById('userMints').textContent = mints.toNumber();
                } catch (error) {
                    console.error('Error updating user mints:', error);
                }
            }
        }

        function updateProgress(current, total) {
            const percentage = (current / total) * 100;
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = 
                `${current.toLocaleString()} / ${total.toLocaleString()}`;
        }

        function showStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = 'status-message ' + type;
            
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }
        }
    </script>
</body>
</html>


